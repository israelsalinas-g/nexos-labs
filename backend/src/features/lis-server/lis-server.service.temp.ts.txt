import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as net from 'net';
import { LabResultsService } from '../lab-results/lab-results.service';

@Injectable()
export class LisServerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(LisServerService.name);
  private server: net.Server;
  private readonly port: number;

  constructor(
    private configService: ConfigService,
    private labResultsService: LabResultsService,
  ) {
    this.port = this.configService.get<number>('LIS_PORT', 5600);
  }

  onModuleInit() {
    this.logger.log('Initializing LIS Server...');
    this.startServer();
  }

  onModuleDestroy() {
    if (this.server) {
      this.server.close(() => {
        this.logger.log('LIS Server stopped');
      });
    }
  }

  private startServer() {
    this.server = net.createServer((socket) => {
      const ipv4Address = socket.remoteAddress?.replace(/^::ffff:/, '') || 'unknown';
      this.logger.log('==================== NUEVA CONEXIÓN ====================');
      this.logger.log(`Conexión entrante desde ${ipv4Address}:${socket.remotePort}`);
      
      socket.setEncoding('utf8');
      
      let messageTimer: NodeJS.Timeout | null = null;
      let currentResult: { obr: string | null; obxs: string[] } = {
        obr: null,
        obxs: []
      };

      socket.on('data', (data: string) => {
        this.logger.log(`Datos recibidos de ${ipv4Address}:${socket.remotePort}`);
        this.logger.debug(data);
        
        if (messageTimer) {
          clearTimeout(messageTimer);
        }

        const cleanData = data
          .replace(/\r/g, '')
          .replace(/\n+/g, '\n')
          .trim();

        const segments = cleanData.split('\n');
        
        for (const segment of segments) {
          this.logger.debug(`Procesando segmento: ${segment}`);
          
          if (segment.startsWith('OBR|')) {
            if (currentResult.obr && currentResult.obxs.length > 0) {
              const message = [currentResult.obr, ...currentResult.obxs].join('\n');
              this.processMessage(message, socket);
            }
            
            currentResult.obr = segment;
            currentResult.obxs = [];
            this.logger.debug('Nueva muestra iniciada');
            
          } else if (segment.startsWith('OBX|')) {
            if (currentResult.obr) {
              currentResult.obxs.push(segment);
              this.logger.debug(`OBX agregado a la muestra (total: ${currentResult.obxs.length})`);
            }
          }
        }
        
        messageTimer = setTimeout(() => {
          if (currentResult.obr && currentResult.obxs.length > 0) {
            const message = [currentResult.obr, ...currentResult.obxs].join('\n');
            this.logger.debug('Procesando muestra final por timeout');
            this.processMessage(message, socket);
            currentResult = { obr: null, obxs: [] };
          }
        }, 1000);
      });

      socket.on('end', () => {
        this.logger.debug(`Conexión finalizada: ${ipv4Address}:${socket.remotePort}`);
      });

      socket.on('error', (error) => {
        this.logger.error(`Error de socket: ${error.message}`);
      });

      this.sendAcknowledgment(socket);
    });

    this.server.listen(this.port, '0.0.0.0', () => {
      this.logger.log(`LIS Server escuchando en puerto ${this.port} (IPv4)`);
    });
  }

  private async processMessage(message: string, socket: net.Socket) {
    try {
      this.logger.debug('Procesando mensaje:', message);
      
      // Determinar tipo de mensaje
      const messageType = this.identifyMessageType(message);
      this.logger.debug(`Tipo de mensaje: ${messageType}`);
      
      switch (messageType) {
        case 'RESULT':
          await this.processLabResult(message, socket);
          break;
        case 'QUERY':
          await this.processQuery(message, socket);
          break;
        case 'HEARTBEAT':
          this.processHeartbeat(socket);
          break;
        default:
          this.sendNegativeAcknowledgment(socket, 'Tipo de mensaje no reconocido');
      }
    } catch (error) {
      this.logger.error('Error procesando mensaje:', error);
      this.sendNegativeAcknowledgment(socket, error.message);
    }
  }

  private async processLabResult(message: string, socket: net.Socket) {
    try {
      this.logger.debug('Procesando resultado de laboratorio');
      const results = await this.labResultsService.processHL7Data(message);
      
      if (results && results.length > 0) {
        const sampleNumber = results[0].sampleNumber;
        this.logger.debug(`Resultado guardado: ${sampleNumber}`);
        this.sendPositiveAcknowledgment(socket, sampleNumber);
      } else {
        throw new Error('No se pudo procesar el resultado');
      }
    } catch (error) {
      this.logger.error('Error procesando resultado:', error);
      throw error;
    }
  }

  private async processQuery(message: string, socket: net.Socket) {
    socket.write('QUERY_RESPONSE:OK\r\n');
  }

  private processHeartbeat(socket: net.Socket) {
    socket.write('PONG\r\n');
  }

  private identifyMessageType(message: string): string {
    if (message.includes('OBR|') && message.includes('OBX|')) {
      return 'RESULT';
    }
    if (message.includes('PING') || message.includes('HEARTBEAT')) {
      return 'HEARTBEAT';
    }
    if (message.includes('QUERY') || message.includes('REQUEST')) {
      return 'QUERY';
    }
    return 'UNKNOWN';
  }

  private sendAcknowledgment(socket: net.Socket) {
    socket.write('LIS_SERVER_READY\r\n');
  }

  private sendPositiveAcknowledgment(socket: net.Socket, sampleNumber?: string) {
    const ack = sampleNumber ? `ACK:${sampleNumber}:SUCCESS\r\n` : 'ACK:SUCCESS\r\n';
    socket.write(ack);
  }

  private sendNegativeAcknowledgment(socket: net.Socket, error: string) {
    socket.write(`NACK:ERROR:${error}\r\n`);
  }
}